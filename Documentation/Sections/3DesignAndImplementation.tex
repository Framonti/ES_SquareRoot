For our project we used the Hardware Description Language (HDL) SystemVerilog. SystemVerilog allows to create a device-independent representation of digital logic and is the de-facto standard for digital design and expecially for verification (together with VHDL). 
In SystemVerilog, the \emph{modules} are the basic building blocks. SystemVerilog design consists in interconnected modules.
Our implementation is based on two interconnected modules:

\begin{itemize}
\item \emph{lampFPU\_sqrt.sv} is the top module, called from the external component of the FPU; it mainly computes the exponent of the number we want the Square Root of, manages some special cases (Square Root of NaN, Square Root of negative number, etc.) and instantiates SquareRootModule.sv
\item \emph{SquareRootModule.sv} implements Goldschmidt's algorithm for the Mantissa of a bfloat16 number. 
\end{itemize}

Our source code also uses some functions and constants in order to make the design parametric. We imported the already existing package \emph{lampFPU\_pkg.sv} containing some useful parameters. We then added some other values and functions we needed. We highlight that in doing so we greatly accelerated the integration process of our modules with the rest of the FPU. \\

The Square Root algorithm requires to compute not only the Mantissa, but the exponent too. \emph{lampFPU\_sqrt.sv} and  \emph{SquareRootModule.sv} need to collaborate in order to obtain the correct result. 
\begin{itemize}
\item If the exponent is even, we simply divide it by 2 in the external module \emph{lampFPU\_sqrt.sv}  (so we right shift the exponent).
\item If the exponent is odd, simply right shifting would not produce the right result. In order to compute the correct final value, we make the exponent even by exploiting:
$$F = (-1)^{S}*M*2^{E}  = (-1)^{S}*(M*2)*2^{E-1} $$
We can now divide by 2 the exponent and we inform the internal module that the exponent was odd with the input \emph{is\_exp\_odd\_i}. \\
We then exploit a trivial property of the Square Root:
$$ \sqrt{2*M} = \sqrt{2} * \sqrt{M} $$
So, we actually pass M (and not $2 * M$) to the internal module, but we multiply the result computed by Goldschmidt's algorithm by $\sqrt{2}$ before returning it.
\end{itemize} 

\subsection{SquareRootModule.sv}
We firstly describe the SquareRootModule.sv module. \\
In general, \emph{SquareRootModule.sv} takes as input an 8-bits Mantissa M between 1.0 (8b'100000000) and 1.9921875 (8b'11111111) and returns seven bits representing $\sqrt{M}$ (the first bit is implicity 1, as expected by the IEEE 754 standard).\\
%----- add module interface ---
The sequential logic of \emph{SquareRootModule.sv} implements a synchronous reset of the module, setting to zero all the internal wires if the input \emph{rst} is 1. Otherwise, it saves the values computed by the combinational logic into internal registers.\\
The combinational logic of \emph{SquareRootModule.sv} implements a Finite State Machine with four different states:
\begin{enumerate}
\item Every times it starts, we compute the various values required by the algorithm, but we don't save them untill we're in the right State.
\item In the IDLE state, we initialize our internal variables as described in Section \ref{goldschmidt}, only if the external input \emph{doSqrt\_i} signals to start the computation and we're not in one of the special cases (Square Root of NaN, Square Root of Zero...). To note, we declare the number 3 as 9'b110000000; since our Significant occupies 8 bits and is between 1.0 and 1.9921875, in order to represent the number 3 we need to add an additional bit. 
\item SQRT\_B is the output state; if $R_i$ is 1, we stop the computation, return the result and signal the end by setting \emph{valid\_next} as 1. If the exponent of the bfloat16 we want the square root of is odd, we first multiply $X_i$ by $\sqrt{2}$, and then we took the 8 most significant bits. Since Goldschmidt's algorithm doesn't yeld a precise LSB, we round the result based on the 8th and 7th bit of x\_tmp, which has 16 bits of precision. Instead, if the estimation of the square root is not good enough, we perform another iteration of the algorithm, by updating \emph{b\_next} and moving to the next state.
\item In the SQRT\_R state, we update $R_i$ as requested by the algorithm.
\item In the SQRT\_XY state, we update $X_i$ and $Y_i$ as requested by the algorithm and move back to SQRT\_B.
\end{enumerate}

\subsection{lampFPU\_sqrt.sv}
We now describe the lampFPU\_sqrt.sv module.\\
In general, \emph{lampFPU\_sqrt.sv} module instantiates \emph{SquareRootModule.sv}, computes the final exponent and manages some special cases.\\
% add why don't need to check underflow/overflow and normalization
%add module interface%
The sequential logic of  \emph{lampFPU\_sqrt.sv} reset to zero the module's internal wires and the outputs when the input \emph{rst} is 1. Otherwise, it saves some of the input into internal registers and updates the outputs.\\
The combinational logic of \emph{lampFPU\_sqrt.sv} firstly checks if we're trying to compute the Square Root of a special case, using the function \emph{FUNC\_calcInfNanZeroResSqrt}. We have the following:
\begin{itemize}
\item $\sqrt{+0}$ = $+0$ 
\item $\sqrt{-0}$ = $-0$
\item $\sqrt{NaN}$ = NaN
\item $\sqrt{+ \infty}$  =  $+\infty$
\item $\sqrt{- \infty}$ =  NaN
\item $\sqrt{- X}$ = NaN  (X is any generic number) 
\end{itemize}

If we are not in a special case, we compute the exponent and wait until the internal module computes the square root of the Mantissa (we uses  \emph{srm_valid} for it) and then we return the final value as outputs. \\

\clearpage
