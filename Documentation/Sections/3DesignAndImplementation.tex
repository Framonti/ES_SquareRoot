For our project we used the Hardware Description Language (HDL) SystemVerilog. SystemVerilog allows to create a device-independent representation of digital logic and is the de-facto standard for digital design and expecially for verification (together with VHDL). 
In SystemVerilog, the \emph{modules} are the basic building blocks. SystemVerilog design consists in interconnected modules.
Our implementation is based on two interconnected modules:

\begin{itemize}
\item \emph{lampFPU\_sqrt.sv} is the top module, called from the external component of the FPU; it mainly computes the exponent of the number we want the Square Root of, manages some special cases (Square Root of NaN, Square Root of negative number, etc.) and instantiates SquareRootModule.sv
\item \emph{SquareRootModule.sv} implements Goldschmidt's algorithm for the Mantissa of a bfloat16 number. 
\end{itemize}

Our source code also uses some functions and constants in order to make the design parametric. We imported the already existing package \emph{lampFPU\_pkg.sv} containing some useful parameters. We then added some other values and functions we needed. We highlight that in doing so we'll greatly accelerate the integration process of our modules with the rest of the FPU. 

\subsection{SquareRootModule.sv}
We firstly describe the SquareRootModule.sv module. 
%---- add generic comments ----
%(write here that S is always between 8b'10000000 and 8'b11111111, so between 1.0 and 1.9921875)
%(write here why we need to multiply by sqrt of 2 if exp is odd)
%
%----- add module interface ---\\
%--- add sequential logic comments ---- \\

The combinational logic of SquareRootModule.sv implements a Finite State Machine with four different states:
\begin{enumerate}
\item In the IDLE state, we initialize our internal variables as described in Section \ref{goldschmidt}, only if the external input \emph{doSqrt\_i} signals to start the computation. To note, we declare the number 3 as 9'b110000000; since our Significant occupies 8 bits and is between 1.0 and 1.9921875, in order to represent the number 3 we need to add an additional bit. 
\item SQRT\_B is the output state; if $R_i$ is 1, we stop the computation, return the result and signal the end by setting \emph{valid\_next} as 1. If the exponent of the bfloat16 we want the square root of is odd, we first multiply $X_i$ by $\sqrt{2}$, and then we took the 8 most significant bits. Since Goldschmidt's algorithm doesn't yeld a precise LSB, we round the result based on the 8th and 7th bit of x\_tmp, which has 16 bits of precision. Instead, if the estimation of the square root is not good enough, we perform another iteration of the algorithm, by updating \emph{b\_next} and moving in the next state.
\item In the SQRT\_R state, we update $R_i$ as requested by the algorithm.
\item In the SQRT\_XY state, we update $X_i$ and $Y_i$ as requested by the algorithm and move back to SQRT\_B.
\end{enumerate}


\clearpage
