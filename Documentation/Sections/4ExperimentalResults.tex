\subsection{Test Setup}
In order to properly validate our implementation, we tested our design using a test-bench; this test-bench can generate random numbers, compute the results of our implementation and then compare them against the results of the C function \emph{sqrtf} (that can be found in \emph{math.h}).  \\
All the other functions and operations already developed for the FPU were tested this way, so we extended two existing files:
\begin{itemize}
\item dpi\_lampFPU.c is a C file; we added the functions \emph{DPI\_sqrt} and \emph{DPI\_invSqrt}. Given a value X, They return the value of $\sqrt{X}$ and $\frac{1}{\sqrt{X}}$, as unsigned integer representing a number in binary32.
\item tb\_lampFPU.sv is a SystemVerilog file; it instantiates the FPU, imports the C functions and compares their results with the ones produced by the top module. 
\end{itemize}

In order to test our implementation, we added two different tasks:
\begin{itemize}
\item \emph{TASK\_doSqrt\_op} takes as input the number X we want the square root of, calls the right C function defined in dpi\_lampFPU.c depending on the opcode, and saves the result. Then, the task rounds this result and compute $\sqrt{X}$ or $\frac{1}{\sqrt{X}}$ using our implementation. Then, the two results are compared. If they're the same, the test is passed, otherwise it fails. 
\item \emph{TASK\_testSqrt} creates a loop with 5000 iterations; in each one, it randomly generates values for the sign, the exponent and the mantissa, and calls \emph{TASK\_doSqrt\_op}. It also manages all the special cases, explicitly creating a test for each of them. 
\end{itemize}

\subsection{Results}
We ran our test-bench using the software Vivado, performing a behavioural, post-synthesis and post-implementation simulation.\\
The results completely validate our implementation; out of 5000 tests performed, we're able to correctly compute the square root of all of them, obtaining zero rejections. \\
For the inverse square root, instead, we have a very small set of tests rejected (21 out of 5000, the 0,42\%); in all cases, our implementation returns the right exponent and sign, but has a mantissa one bit greater than expected. It problem probably lies in the rounding function, since the mantissa computed by our implementation is very close to the right value.  

\subsection{Algorithm Efficiency}
In this section we show the efficiency of the algorithm for one randomly selected value. 



\clearpage